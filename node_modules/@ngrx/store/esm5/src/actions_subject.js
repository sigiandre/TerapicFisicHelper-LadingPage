import { __decorate, __extends, __metadata } from "tslib";
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export var INIT = '@ngrx/store/init';
var ActionsSubject = /** @class */ (function (_super) {
    __extends(ActionsSubject, _super);
    function ActionsSubject() {
        return _super.call(this, { type: INIT }) || this;
    }
    ActionsSubject.prototype.next = function (action) {
        if (typeof action === 'function') {
            throw new TypeError("\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().");
        }
        else if (typeof action === 'undefined') {
            throw new TypeError("Actions must be objects");
        }
        else if (typeof action.type === 'undefined') {
            throw new TypeError("Actions must have a type property");
        }
        _super.prototype.next.call(this, action);
    };
    ActionsSubject.prototype.complete = function () {
        /* noop */
    };
    ActionsSubject.prototype.ngOnDestroy = function () {
        _super.prototype.complete.call(this);
    };
    ActionsSubject = __decorate([ __metadata("design:paramtypes", [])
    ], ActionsSubject);
ActionsSubject.ɵfac = function ActionsSubject_Factory(t) { return new (t || ActionsSubject)(); };
ActionsSubject.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ActionsSubject, factory: function (t) { return ActionsSubject.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ActionsSubject, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return ActionsSubject;
}(BehaviorSubject));
export { ActionsSubject };
export var ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9uc19zdWJqZWN0LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL3N0b3JlL3NyYy9hY3Rpb25zX3N1YmplY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQXVCLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBSXZDLE1BQU0sQ0FBQyxJQUFNLElBQUksR0FBRyxrQkFBd0MsQ0FBQztBQUc3RDtJQUFvQyxrQ0FBdUI7SUFFekQ7ZUFDRSxrQkFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRUQsNkJBQUksR0FBSixVQUFLLE1BQWM7UUFDakIsSUFBSSxPQUFPLE1BQU0sS0FBSyxVQUFVLEVBQUU7WUFDaEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxxUEFHNkQsQ0FBQyxDQUFDO1NBQ3BGO2FBQU0sSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7WUFDeEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQ2hEO2FBQU0sSUFBSSxPQUFPLE1BQU0sQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO1lBQzdDLE1BQU0sSUFBSSxTQUFTLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUMxRDtRQUNELGlCQUFNLElBQUksWUFBQyxNQUFNLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQsaUNBQVEsR0FBUjtRQUNFLFVBQVU7SUFDWixDQUFDO0lBRUQsb0NBQVcsR0FBWDtRQUNFLGlCQUFNLFFBQVEsV0FBRSxDQUFDO0lBQ25CLENBQUM7SUExQlUsY0FBYyxlQUFlLFNBRHpDLFVBQVUsRUFBRSxyQkFDTDtPQUFLLGNBQWMsQ0EyQjFCOzs7OztnREFDRDtJQURBLHFCQUFDO0NBQUEsQUEzQkQsQ0FBb0MsZUFBZSxHQTJCbEQ7U0EzQlksY0FBYztBQTZCM0IsTUFBTSxDQUFDLElBQU0seUJBQXlCLEdBQWUsQ0FBQyxjQUFjLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSwgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL21vZGVscyc7XG5cbmV4cG9ydCBjb25zdCBJTklUID0gJ0BuZ3J4L3N0b3JlL2luaXQnIGFzICdAbmdyeC9zdG9yZS9pbml0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFjdGlvbnNTdWJqZWN0IGV4dGVuZHMgQmVoYXZpb3JTdWJqZWN0PEFjdGlvbj5cbiAgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IHR5cGU6IElOSVQgfSk7XG4gIH1cblxuICBuZXh0KGFjdGlvbjogQWN0aW9uKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFxuICAgICAgICBEaXNwYXRjaCBleHBlY3RlZCBhbiBvYmplY3QsIGluc3RlYWQgaXQgcmVjZWl2ZWQgYSBmdW5jdGlvbi5cbiAgICAgICAgSWYgeW91J3JlIHVzaW5nIHRoZSBjcmVhdGVBY3Rpb24gZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGJlZm9yZSBkaXNwYXRjaGluZyB0aGUgYWN0aW9uLiBGb3IgZXhhbXBsZSwgc29tZUFjdGlvbiBzaG91bGQgYmUgc29tZUFjdGlvbigpLmApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFjdGlvbnMgbXVzdCBiZSBvYmplY3RzYCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBY3Rpb25zIG11c3QgaGF2ZSBhIHR5cGUgcHJvcGVydHlgKTtcbiAgICB9XG4gICAgc3VwZXIubmV4dChhY3Rpb24pO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgc3VwZXIuY29tcGxldGUoKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQUNUSU9OU19TVUJKRUNUX1BST1ZJREVSUzogUHJvdmlkZXJbXSA9IFtBY3Rpb25zU3ViamVjdF07XG4iXX0=